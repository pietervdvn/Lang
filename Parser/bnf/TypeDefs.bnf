TypeDefs

author		"Pieter Vander Vennet"
date		[2013, 12, 23, 01, 18, 42]
desc		"The syntaxis of all kind of TypeDefinitions."

import Prelude
import Comments
import Functions
import Types


 -------------
 -- ADT DEF --
 -------------

-- the constructor, e.g. 'True'
_$constructName	::= globalIdent
_types		::= baseType+
_freeTypes	::= constrFreeType*
-- one ore more identifiers, e.g. 'x y', for use in 'x y : Int'
_idents		::= localIdent+
-- a single named type, e.g. 'x y : Int' or 'name:String'
_named		::= idents subTypeT type

-- comment and newline administrativa
_nlt		::= "\n\t"
_nltComment	::= (mlcomment nlt? | comment nlt? | nlt)

-- first item is obligatedly named, to disambituate the parser; the first compromise of the language...
_namedSum	::= named (";" named)*

_constructor	::= nltComment? "_"? constructName (namedSum | types)? nltComment?
_prod		::= "\{" constructor ("," constructor)* "\}"
{- a comment is obligated, but an error will be given by another fase then the parser
Making a type private has the only result that all it's constructors are private

-- example
data _ ABC	= AB | BC
==
data ABC	= _AB | _BC
-}
 typeDecl		::= "type" "_"? typeIdent freeTypes "=" (prod | type) ("\+" type)*

{-

data _BTree a where a is Ord
		= Top a (BTree a) (BTree a)
		| Nil
data a is Ord => _BTree a
		=

data _Btree (a: Ord) (b:[a])
		= {Top contents:a; left:BTree a; right: BTree a,
			Nil}
-}

 -------------
 -- SUB DEF --
 -------------

 subtypeDecl	::= "subtype" "_"? typeIdent freeTypes "=" type

 ------------------------
 -- CATEGORY+INSTANCE DEF --
 ------------------------

-- comments are obligated, but it's not the parsers task to generate error messages
 catDecl	::= ("category"|"cat") globalIdent freeTypes subclass? categoryBody
_subclass	::= subTypeWords type
_categoryBody	::= categoryStm*
_categoryStm	::= "\n+\t" (law | declaration | mlcomment | comment)

 -- ''instance Set (a:Show) is Show'',
 instance	::= "instance" knownType constrFreeType* subTypeWords type





{-
-- (only comments below this point) --


data
====

type Data a 	= {A a , B Int}
--or
data Record	= {Record String Int Bool, Exception String LineNr}
-- want named fields?

data Record	= {A i : Int; B b : Bool; i : Int; path name : Name}

type constraints can appear both on the right and left side, within field declarations. This might be a bit confusing.
Field declarations are separated by semicolons.
type Data (a:Monoid)	= {A monoid : (a:Monoid);  monoid : a}

record syntax also creates functions to set and modify: (e.g. for the last one:)

seti	: Record -> Int -> Record
modi	: Record -> Int -> Int -> Record

e.g. 'record.modi (+1)' or (.modi (+1) )

To make a single constructor private, add a _ before the constructor

-- docstring for record
type Record	= {_A i : Int	-- docstring for record a
		-- alternative docstring location for b
		, B b : Bool	-- docstring for record b
		, C	, D}	-- docstring for *both* C and D
(A is private, B is public)

To make all the constructors private, put an underscore before the name

data _Record	= ...


Type generation by constructors
-------------------------------

The constructors also create a new type.

This means that constructors become types too. This however is something to think about.


Classes
=======

A typeclass declares a number of functions (without the implementation). When a certain type has all these functions, it is (automatically) part of this typeclass.
E.g.

cat Show where
	show	: Show -> String


Bool implements show, there is *no* need to make it explicit:

show : Bool -> String
True	= "True"
False	= "False"


cat Functor a where
	map	: (a -> b) -> functor a -> functor b

Everywhere 'functor' is used, the same subtype will be infered. In cat defs, there is no need to explicitly write (functor a:Functor a).

Compare with:

cat Collection a where
	addAll	: Collection a -> collection a -> collection a

which implies that a collection should be able to merge in any other collection; e.g.

addAll	: Collection a -> List a -> List a
addAll	= ...

Which feels quite a bit object-oriented, especially with .-syntax:

list.addAll set


Default methods can be written as

print	: Show -> IO ()
s	= putStrLn $ show s


One can define laws with the cat. If the laws are not fullfilled, the type is NOT part of the cat.

cat Monad a where
	~ neutral element: return a >>= f 	= f a
	~ neutral element: m >>= return 	= m
	return 	: a -> m a
	(>>=)	: Monad m => m a -> (a -> m b) -> m b

Extending classes
-----------------

Sometimes, classes can be extended. For instance, each ''Collection'' should be a ''Functor''.

We express this requirements as

cat Collection a in Functor :
	...


Instance
========

Instance is not obligated. If it is stated, the compiler will check it actually implements all the needed stuff, with the needed laws.

Are types public?
================

As soon as a single function is public, all of the types of it's arguments are public too.
To keep a type private, do not export any function which uses this type.

Note that types can be hidden in imports
-}
